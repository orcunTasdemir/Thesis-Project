# return game instead of population

note1: Population overload is reached everytime we run the simulation for agent energy level 1 with food eenrgy level from 1 to 30, which means that the

implement the energy rule over the age rule and implement the population ceiling DONE

only 6 percent of the arena is food

important that the offspring is beingle spawned close to our agent as that increases their strength2-fold, by having children and then by having more peop around himself.

Instead of changing other things, change the energy of the food super low and the number of food the same as their experiment

maybe make the learning metric worse

In experiments, there is proof for how if the agent energy is not halved the boom is effected badly. With Agentergy

ITERPOLATED
added ANN so that the angle is translated between -1, 1 and distance is also translated from 0 to 1

elif (fd == 1 and agent_x > 0 and not isinstance(game.field.array[agent_x - move, agent_y], Agent)):
game.move_agent_out(agent)
agent_x = agent_x - move
elif (fd == 2 and agent_y > 0 and not isinstance(game.field.array[agent_x, agent_y - move], Agent)):
game.move_agent_out(agent)
agent_y = agent_y - move
elif (fd == 3 and agent_x < edge and not isinstance(game.field.array[agent_x + move, agent_y], Agent)):
game.move_agent_out(agent)
agent_x = agent_x + move
if isinstance(game.field.array[agent_x, agent_y], Food): # or game.food_energy
agent.energy += game.field.array[agent_x, agent_y].energy # print('energy of the food:', game.field.array[agent_x, agent_y].energy)
game.delete_food(agent_x, agent_y)
numFoodEaten += 1
agent.x = agent_x
agent.y = agent_y
game.field.array[agent.x, agent.y] = agent




# def food_finding_challenge(sample_size : int, iss_game : Game, sss_game : Game, environment : str = "Test"):
    
#     iss_games_averages = []
    
    
#     iss_agents_list_0 = list(iss_game.agents.items())
#     iss_agents_list = []
#     for i in range(sample_size):
#         _, iss_agent = random.choice(iss_agents_list_0) 
#         iss_agents_list.append(iss_agent)
    
#     sss_games_averages = []
#     #sample agents from the individual survival game
#     sss_agents_list_0 = list(sss_game.agents.items())
#     sss_agents_list = []
#     for i in range(sample_size):
#         _, sss_agent = random.choice(sss_agents_list_0) 
#         sss_agents_list.append(sss_agent)
   
#     for agent in iss_agents_list:
#         food_num = 0
#         game = Game(game_type="ISS", environment_type= environment)
#         print("agent name: ", agent.name)
#         game.agents[agent.name] = agent
#         game.put_one_agent()
#         game.put_food(challenge=True)
#         _, simulation_data, _, _ = simulate(game, 20000, aptitude_mode=True)
#         food_captured = []
#         for key in simulation_data:
#             if key == "header":
#                 continue
#             food_num += simulation_data[key]['numFoodEaten']
#             food_captured.append(food_num)
#         iss_games_averages.append(food_captured)
        
#     for agent in sss_agents_list:
#         food_num = 0
#         game = Game(game_type="ISS", environment_type= environment)
#         game.agents[agent.name] = agent
#         game.put_one_agent()
#         game.put_food(challenge=True)
#         _, simulation_data, _, _ = simulate(game, 20000, aptitude_mode=True)
#         food_captured = []
#         for key in simulation_data:
#             if key == "header":
#                 continue
#             food_num += simulation_data[key]['numFoodEaten']
#             food_captured.append(food_num)
#         sss_games_averages.append(food_captured)
        
#     #get the means
#     iss_games_average = np.mean([iss_games_averages], axis=1)
#     sss_games_average = np.mean([sss_games_averages], axis=1)
        
#     return [iss_games_average, sss_games_average]